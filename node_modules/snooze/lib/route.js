var _ = require('lodash');
var q = require('q');
var fs = require('fs');
var mmm = require('mmmagic');
var Magic = mmm.Magic;
var _Magic = new Magic(mmm.MAGIC_MIME_TYPE);
var colors = require('colors');
var _dto = require('./dto');

var _new = function(module, method, path, options) {
	var _module = null;
	var _method = null;
	var _path = null;
	var _controller = null;
	var _action = null;
	var _validators = [];

	// Expectations
	var _request = null;
	var _requestParams = null;
	var _requestBody = null;
	var _requestQuery = null;
	var _response = null;

	// Parent and children are set by the routeManager
	var _parent = null;
	var _children = [];

	// Route Class

	
	_module = module;

	if(path === null || path === undefined || path.length < 1) {
		module.fatal('Undefined Route Path');
	} else {
		_path = path;
	}

	switch(method.toLowerCase()) {
		case 'get':
			_method = 'get';
			break;
		case 'post':
			_method = 'post';
			break;
		case 'put':
			_method = 'put';
			break;
		case 'delete':
			_method = 'delete';
			break;
		case 'resource':
			_method = 'resource';
			break;
		default:
			module.fatal('Unknown Method: `' + method + '` on path: ' + path);
	}

	if(typeof options === 'object') {
		if(options.validators) {
			var auth = options.validators;
			if(typeof auth === 'string') {
				_validators = [auth];
			} else if (typeof auth === 'object' && auth.length !== undefined) {
				_validators = auth;
			} else {
				module.fatal('Validator option expected to be a string or array of string on route: ' + path);
			}
		}

		if(_method !== 'resource') {
			if(options.controller) {
				_controller = options.controller;
			} else {
				module.fatal('Controller required for route: ' + path);
			}

			if(options.action) {
				_action = options.action;
			} else {
				module.fatal('Action required for route: ' + path);
			}
		}

		if(options.request !== undefined) {
			var req = options.request;
			_request = req;

			var body = req.body;
			var params = req.params;
			var query = req.query;

			var dtoList = [
				{
					src: body,
					name: 'body',
					res: '_requestBody',
					dtoNameType: 'RouteBody'
				},
				{
					src: params,
					name: 'params',
					res: '_requestParams',
					dtoNameType: 'RouteParams'
				},
				{
					src: query,
					name: 'query',
					res: '_requestQuery',
					dtoNameType: 'RouteQuery'
				}
			];

			for(var i = 0; i < dtoList.length; i++) {
				var dtoItem = dtoList[i];

				if(dtoItem.src !== undefined) {
					if(typeof dtoItem.src === 'string') {
						var _DTO = module.getDTO(dtoItem.src);
						if(_DTO !== undefined) {
							eval(dtoItem.res + ' = _DTO.$get()');
						} else {
							module.fatal('DTO doesn\'t exist in route request for query: ' + method + ' => ' + path + ' : ' + dtoItem.src);
						}
					} else {
						var dto = _dto(method+':'+path+':'+dtoItem.dtoNameType, module);

						for(var key in dtoItem.src) {
							var json = dtoItem.src;

							if(key !== '__methods') {
								var type = json[key].type || null;
								var def = json[key].default || null;
								var description = json[key].description || null;
								var example = json[key].example || null;
								var required = json[key].required || false;

								dto.addProperty(key, type, def, description, example, required);
							}
						}

						eval(dtoItem.res + ' = dto.$get();');
					}
				}
			}
		}

		if(options.response) {
			var res = options.response;
			_response = res;
		}
	} else {
		module.fatal('Options cannot be an array on route: ' + path);
	}

	var bind = function(app) {
		var resource = false;
		var mthd = _method;

		if(_method === 'resource') {
			resource = true;
			mthd = 'get';
		}

		app[mthd](_path, function(req, res) {
			var _res = {
				send: function(code, msg) {
					if(typeof msg === 'string') {
						msg = {message:msg};
					}

					var files = req.files || {};
					_cleanupTmp(files);

					res.send(code, msg);
				},
				setHeader: function(key, value) {
					res.setHeader(key, value);
				}
			};

			var completeReq = function() {
				if(resource) {
					var filepath = process.cwd() + req.url;

					if(fs.existsSync(filepath)) {
						var stats = fs.statSync(filepath);

						if(stats.isDirectory(filepath)) {
							res.send(403, "<h1>Forbidden</h1>");
						} else {
							_Magic.detectFile(filepath, function(err, result) {
								res.setHeader('content-type', result)
								res.send(200, fs.readFileSync(process.cwd() + req.url));
							})
						}
					} else {
						res.send(404, "<h1>Not Found</h1>");
					}
				} else {
					var params = req.params || {};
					var query = req.query || {};
					var body = req.body || {};
					var files = req.files || {};
					var basicAuth = {
						username: '',
						password: ''
					};

					var header = req.headers['authorization'] || null;
					if(header !== null) {
						token = header.split(/\s+/).pop()||'';
						auth = new Buffer(token, 'base64').toString();
						parts = auth.split(/:/);

						username = parts[0];
						password = parts[1];

						basicAuth.username = username;
						basicAuth.password = password;
					}

					ctrl = _module.getController(_controller);
					if(ctrl !== undefined) {
						if(ctrl[_action] !== undefined) {
							ctrl[_action](_res, {'params': params, 'query': query, 'body': body, 'files': files, 'basicAuth': basicAuth});
						} else {
							var errStr = 'Cannot call ' + _action + ' on ' + _controller + '. Route ' + _path + ' method ' + _method + '.';
							module.fatal(errStr);
							_res.send(500, errStr);
						}
					} else {
						var errStr = 'Controller ' + _controller + ' does not exist for route ' + _path + '.';
						module.fatal(errStr);
						_res.send(500, errStr);
					}
				}
			};

			// Validators should handle this..
			var rejectReq = function(msg) {
				if(msg !== undefined) {
					var code = msg[0];
					var message = msg[1];

					_res.send(code, message);
				} else {
					_res.send(500, 'Validation failed for ' + _path + ' but no rejection process defined.');
				}
			};

			var validReq = function() {
				for(var i = 0; i < validatorResults.length; i++) {
					var vld = validatorResults[i];
					if(vld.valid === false) {
						return false;
					}
				}

				return true;
			};

			// DTOs

			var dtoTesters = [
				{
					src: _requestParams,
					data: req.params
				},
				{
					src: _requestBody,
					data: req.body
				},
				{
					src: _requestQuery,
					data: req.query
				}
			];

			for(var i = 0; i < dtoTesters.length; i++) {
				var tester = dtoTesters[i];
				if(tester.src !== null) {
					var result = tester.src.$test(tester.data);
					if(result !== null) {
						res.send(400, {message: 'Fatal Error in Route ' + _method + ' => ' + _path + ' : ' + result});
					}
				}
			}

			// Validators

			var validatorResults = [];

			if(_validators.length > 0) {
				var promises = [];
				for(var i = 0; i < _validators.length; i++) {
					var nm = _validators[i];
					var result = _module.getValidator(nm).validate(req);
					validatorResults.push(result);

					if(result.promise !== null) {
						promises.push(result.promise);
					}
				}

				if(promises.length > 0) {
					q.all(promises).then(function() {
						completeReq();
					}).fail(function(msg) {
						rejectReq(msg);
					});
				} else {
					if(validReq() === true) {
						completeReq();
					} else {
						rejectReq();
					}
				}
			} else {
				completeReq();
			}
		});
	}

	var _cleanupTmp = function(filesObj) {
		for(var key in filesObj) {
			var img = filesObj[key];
			var path = img.path;

			var path = process.cwd() + '/' + path;

			if(fs.existsSync(path)) {
				fs.unlink(path, function(err) {
					module.fatal(err);
				});
			}
		}
	};

	var getPath = function() {
		return _path;
	};

	var getMethod = function() {
		return _method;
	};

	var getController = function() {
		return _controller;
	};

	var getAction = function() {
		return _action;
	};

	var getRequest = function() {
		return _request;
	};

	var getResponse = function() {
		return _response;
	};

	return {
		'getRequest': getRequest,
		'getResponse': getResponse,
		'getPath': getPath,
		'getMethod': getMethod,
		'getController': getController,
		'getAction': getAction,
		'bind': bind
	}
}



module.exports = _new;